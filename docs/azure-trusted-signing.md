# Azure Trusted Signing Integration

This document explains how Windows artifacts generated by the production and nightly release pipelines are signed with [Azure Trusted Signing](https://learn.microsoft.com/azure/artifact-signing/overview) without exposing private keys.

## Prerequisites

1. **Trusted Signing resources**
    - An Artifact Signing account and certificate profile configured for code signing (public trust is recommended for public distribution).
    - A timestamp service URL (the platform provides `http://timestamp.acs.microsoft.com`).
2. **Azure AD application** with the _Artifact Signing Certificate Profile Signer_ role scoped to the certificate profile you plan to use.
3. **GitHub secrets** listed below so the workflow can authenticate non-interactively.

## Required GitHub secrets

| Secret                                | Purpose                                                                                                        |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `AZURE_TENANT_ID`                     | Azure AD tenant that owns the Artifact Signing account.                                                        |
| `AZURE_CLIENT_ID`                     | Client ID of the app registration that is allowed to sign.                                                     |
| `AZURE_CLIENT_SECRET`                 | Client secret for the app registration. Consider using OIDC/federated credentials to avoid long-lived secrets. |
| `TRUSTED_SIGNING_ENDPOINT`            | Regional endpoint for the Artifact Signing account (for example, `https://eus.codesigning.azure.net/`).        |
| `TRUSTED_SIGNING_ACCOUNT_NAME`        | Name of the Artifact Signing account.                                                                          |
| `TRUSTED_SIGNING_CERTIFICATE_PROFILE` | Certificate profile that should issue the short-lived signing certificate.                                     |

> Keep `SENTRY_*`, `SUPABASE_*`, and other existing secrets in place; they are still required earlier in the pipeline.

## Workflow behavior

- The jobs running on `windows-latest` in both `prod-release.yml` and `nightly-release.yml` execute the [`azure/artifact-signing-action@v1`](https://github.com/Azure/artifact-signing-action) step immediately after Electron Builder packages the installers.
- Every `.exe` and `.msi` produced under `build/` is signed in place. Portable `.zip` artifacts remain unsigned because the action does not yet support signing archives. The action handles hashing, timestamping, and certificate management by requesting a short-lived certificate from Azure Trusted Signing.
- The action fails if any secret is missing or Azure denies the signing request, which prevents unsigned installers from being uploaded or released.

## Testing the signing step

1. Configure the secrets above in the repository or organization settings.
2. Trigger the `Stable Release` or `Insider Pre-Release` workflow via the `workflow_dispatch` entry point (you can do this on a throwaway branch after updating the version and release notes).
3. Inspect the Windows job logs for the "Sign Windows artifacts with Azure Trusted Signing" step to verify that Azure returned a certificate and that all `.exe`/`.msi` files were processed.
4. Download the Windows artifacts and run `Get-AuthenticodeSignature` locally to validate the signature chain.

## Operational guidance

- Rotate the app registration client secret regularly, or switch the workflow over to GitHub OIDC using the guidance in the [action documentation](https://github.com/Azure/artifact-signing-action/blob/main/docs/OIDC.md).
- Restrict the app registration to the minimum Azure roles necessary (typically only the certificate profile signer role) so compromised credentials cannot be misused elsewhere.
- Monitor signing activity from the Trusted Signing blade in the Azure portal to ensure that every release corresponds to an expected signing request.
